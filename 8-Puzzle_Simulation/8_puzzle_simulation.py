# -*- coding: utf-8 -*-
"""8-Puzzle_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ess-HF74LeNwUD6pkhnhp8nEA9tBEnGf
"""

import random
import heapq
import time
from IPython.display import display, HTML, clear_output

# Define the goal state
GOAL_STATE = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

def is_solvable(state):

    flat_state = [num for row in state for num in row]
    inversions = 0
    for i in range(len(flat_state)):
        for j in range(i + 1, len(flat_state)):
            if flat_state[i] > flat_state[j] and flat_state[i] != 0 and flat_state[j] != 0:
                inversions += 1
    return inversions % 2 == 0

def shuffle_numbers():

    while True:
        numbers = list(range(1, 9)) + [0]
        random.shuffle(numbers)
        state = [numbers[i:i + 3] for i in range(0, 9, 3)]
        if is_solvable(state):
            return state

def create_state_with_empty_at(position):

    shuffled_state = shuffle_numbers()
    empty_pos = divmod(position - 1, 3)  # Convert 1-9 input to (row, col)
    for i in range(3):
        for j in range(3):
            if shuffled_state[i][j] == 0:
                shuffled_state[i][j], shuffled_state[empty_pos[0]][empty_pos[1]] = (
                    shuffled_state[empty_pos[0]][empty_pos[1]],
                    shuffled_state[i][j],
                )
                return shuffled_state


def find_blank(state):

    for i in range(len(state)):
        for j in range(len(state[i])):
            if state[i][j] == 0:
                return i, j

def is_valid(x, y):

    return 0 <= x < 3 and 0 <= y < 3

def generate_successors(state):

    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Up, Down, Left, Right
    blank_x, blank_y = find_blank(state)
    successors = []

    for dx, dy in moves:
        new_x, new_y = blank_x + dx, blank_y + dy
        if is_valid(new_x, new_y):
            # Create a new state by swapping tiles
            new_state = [row[:] for row in state]
            new_state[blank_x][blank_y], new_state[new_x][new_y] = new_state[new_x][new_y], new_state[blank_x][blank_y]
            successors.append(new_state)
    return successors

def heuristic(state):

    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                goal_x, goal_y = divmod(state[i][j] - 1, 3)
                distance += abs(i - goal_x) + abs(j - goal_y)
    return distance

def state_to_tuple(state):

    return tuple(tuple(row) for row in state)

def display_grid(state, step, commentary):

    grid_html = "<table style='border-collapse: collapse; text-align: center;'>"
    for row in state:
        grid_html += "<tr>"
        for cell in row:
            color = "white" if cell != 0 else "gray"
            cell_value = cell if cell != 0 else "&nbsp;"  # Blank space for 0
            grid_html += f"<td style='width: 50px; height: 50px; background-color: {color}; border: 1px solid black;'>{cell_value}</td>"
        grid_html += "</tr>"
    grid_html += "</table>"

    commentary_html = f"<div style='margin-top: 10px;'>{commentary}</div>"

    clear_output(wait=True)
    display(HTML(f"<h3>Step {step}</h3>" + grid_html + commentary_html))
    time.sleep(1)

def a_star(start_state):

    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(GOAL_STATE)


    priority_queue = []
    heapq.heappush(priority_queue, (0, start_tuple))


    g_cost = {start_tuple: 0}
    parent_map = {start_tuple: None}

    while priority_queue:
        current_priority, current_state = heapq.heappop(priority_queue)


        if current_state == goal_tuple:
            return reconstruct_path(parent_map, current_state)


        current_cost = g_cost[current_state]
        current_state_2d = [list(row) for row in current_state]
        for neighbor in generate_successors(current_state_2d):
            neighbor_tuple = state_to_tuple(neighbor)
            new_cost = current_cost + 1


            if neighbor_tuple not in g_cost or new_cost < g_cost[neighbor_tuple]:
                g_cost[neighbor_tuple] = new_cost
                priority = new_cost + heuristic(neighbor)
                heapq.heappush(priority_queue, (priority, neighbor_tuple))
                parent_map[neighbor_tuple] = current_state

    return None

def reconstruct_path(parent_map, end_state):

    path = []
    current = end_state
    while current is not None:
        path.append([list(row) for row in current])
        current = parent_map[current]
    path.reverse()
    return path


if __name__ == "__main__":
    print("Enter the position of the empty cell (1-9):")
    empty_cell = int(input())

    if not (1 <= empty_cell <= 9):
        print("Invalid position!")
    else:
        initial_state = create_state_with_empty_at(empty_cell)

        print("Initial State:")
        for row in initial_state:
            print(row)

        solution = a_star(initial_state)

        if solution:
            print("\nSolution Path:")
            prev_state = solution[0]
            for step, state in enumerate(solution):
                if step == 0:
                    commentary = "Initial state of the puzzle."
                elif step == len(solution) - 1:
                    commentary = "Goal state achieved!"
                else:

                    prev_blank = find_blank(prev_state)
                    curr_blank = find_blank(state)
                    move_direction = ""
                    if curr_blank[0] < prev_blank[0]:
                        move_direction = "Moved blank tile up."
                    elif curr_blank[0] > prev_blank[0]:
                        move_direction = "Moved blank tile down."
                    elif curr_blank[1] < prev_blank[1]:
                        move_direction = "Moved blank tile left."
                    elif curr_blank[1] > prev_blank[1]:
                        move_direction = "Moved blank tile right."

                    commentary = move_direction

                display_grid(state, step, commentary)
                prev_state = state
        else:
            print("No solution found.")