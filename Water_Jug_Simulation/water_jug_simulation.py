# -*- coding: utf-8 -*-
"""Water_Jug_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kB2rnYKFaEYJKmJtG2OnUrmBUJcdhy7a
"""

import time
from IPython.display import display, HTML, clear_output
from collections import deque

def display_jugs_html(state, step, jug_x_capacity, jug_y_capacity, path, commentary):

    x, y = state

    jug_x_height = int((x / jug_x_capacity) * 200)
    jug_y_height = int((y / jug_y_capacity) * 200)

    commentary_html = f"""
    <div style="float: left; margin-left: 20px; width: 200px; height: 200px; overflow-y: auto;">
        <p>{'<br>'.join(commentary)}</p>
    </div>
    """

    html_content = f"""
    <div style="display: flex; align-items: center;">
        <div style="border: 2px solid black; width: 100px; height: 200px; position: relative; margin-right: 20px;">
            <div style="background-color: blue; width: 100%; height: {jug_x_height}px; position: absolute; bottom: 0;"></div>
            <div style="position: absolute; bottom: 0; width: 100%; text-align: center; color: white; font-weight: bold;">
                {x}/{jug_x_capacity}
            </div>
        </div>
        <div style="border: 2px solid black; width: 100px; height: 200px; position: relative; margin-right: 20px;">
            <div style="background-color: blue; width: 100%; height: {jug_y_height}px; position: absolute; bottom: 0;"></div>
            <div style="position: absolute; bottom: 0; width: 100%; text-align: center; color: white; font-weight: bold;">
                {y}/{jug_y_capacity}
            </div>
        </div>
        {commentary_html}
    </div>
    """
    clear_output(wait=True)
    display(HTML(html_content))
    time.sleep(3)

def get_commentary(state, step, jug_x_capacity, jug_y_capacity, path):

    x, y = state
    if step == 1:
        return "Initial state: Both jugs are empty.<br>"


    prev_state = path.get(state)
    if prev_state is None:
        return "Initial state: Both jugs are empty.<br>"
    prev_x, prev_y = prev_state

    if x == jug_x_capacity and y == prev_y:
        return f"Fill Jug X to its capacity ({jug_x_capacity} liters).<br>"
    elif x == prev_x and y == jug_y_capacity:
        return f"Fill Jug Y to its capacity ({jug_y_capacity} liters).<br>"
    elif x == 0 and y == prev_y:
        return "Empty Jug X.<br>"
    elif x == prev_x and y == 0:
        return "Empty Jug Y.<br>"
    elif x > prev_x and y < prev_y:
        return f"Pour water from Jug X to Jug Y.<br>"
    elif x < prev_x and y > prev_y:
        return f"Pour water from Jug Y to Jug X.<br>"
    else:
        return "Perform an action based on the previous state.<br>"

def bfs_water_jug_html(jug_x_capacity, jug_y_capacity, target):
    queue = deque([(0, 0)])  # Starting state: both jugs are empty
    visited = set()  # Track visited states
    path = {}  # To reconstruct the path of operations
    commentary = []

    while queue:
        current_state = queue.popleft()
        x, y = current_state

        # If the target is reached, reconstruct and display the path
        if x == target or y == target:
            solution_path = []
            while current_state in path:
                solution_path.append(current_state)
                current_state = path[current_state]
            solution_path.append((0, 0))  # Initial state
            solution_path.reverse()

            # Display the solution path visually
            print("Starting the solution visualization...\n")
            for step, state in enumerate(solution_path, start=1):
                commentary.append(get_commentary(state, step, jug_x_capacity, jug_y_capacity, path))
                display_jugs_html(state, step, jug_x_capacity, jug_y_capacity, path, commentary)

            print("\nSolution completed!")
            return solution_path

        visited.add(current_state)

        # Generate all possible states from the current state
        successors = [
            (jug_x_capacity, y),  # Fill Jug X
            (x, jug_y_capacity),  # Fill Jug Y
            (0, y),              # Empty Jug X
            (x, 0),              # Empty Jug Y
            (max(0, x - (jug_y_capacity - y)), min(jug_y_capacity, x + y)),  # Pour X -> Y
            (min(jug_x_capacity, x + y), max(0, y - (jug_x_capacity - x)))  # Pour Y -> X
        ]

        for successor in successors:
            if successor not in visited:
                queue.append(successor)
                path[successor] = current_state

    print("No solution found.")
    return None

jug_x = int(input("Enter the capacity of jug_x: "))
jug_y = int(input("Enter the capacity of jug_y: "))
target = int(input("Enter the target capacity to be achieved: "))
solution = bfs_water_jug_html(jug_x, jug_y, target)