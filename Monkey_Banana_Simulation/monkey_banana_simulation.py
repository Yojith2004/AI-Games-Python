# -*- coding: utf-8 -*-
"""Monkey_Banana_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Cv2KAcUt319Y0Vg6__hnxzYxcvi_3qc
"""

import random
import time
from IPython.display import display, HTML, clear_output

# Constants for cell types
EMPTY = 0
BANANA = 1
TABLE = 2

# Possible movements: up, down, left, right, and diagonals
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]


def initialize_grid(grid_size, banana_count, table):

    grid = [[EMPTY for _ in range(grid_size)] for _ in range(grid_size)]
    banana_positions = set()

    # Place bananas randomly, avoiding the table position
    while len(banana_positions) < banana_count:
        x, y = random.randint(0, grid_size - 1), random.randint(0, grid_size - 1)
        if (x, y) != table:
            banana_positions.add((x, y))

    for x, y in banana_positions:
        grid[x][y] = BANANA

    # Place the table
    grid[table[0]][table[1]] = TABLE

    return grid, banana_positions


def display_grid_and_commentary(grid, monkey, banana_positions, table_acquired, eaten_bananas, commentary):

    grid_html = "<table style='border-collapse: collapse; float: left;'>"
    for i in range(len(grid)):
        grid_html += "<tr>"
        for j in range(len(grid[0])):
            cell_color = "white"  # Default empty space color
            cell_num = i * len(grid[0]) + j + 1
            if (i, j) == monkey:
                cell_color = "red" if not table_acquired else "purple"  # Monkey's color changes after acquiring the table
            elif (i, j) in banana_positions:
                cell_color = "green"  # Banana positions
            elif grid[i][j] == TABLE:
                cell_color = "blue"  # Table position
            elif (i, j) in eaten_bananas:
                cell_color = "yellow"  # Eaten bananas

            grid_html += f"<td style='width: 30px; height: 30px; background-color: {cell_color}; border: 1px solid black; text-align: center;'>{cell_num}</td>"
        grid_html += "</tr>"
    grid_html += "</table>"

    # Commentary HTML
    commentary_html = f"""
    <div style="float: left; margin-left: 20px; width: 200px; height: {len(grid) * 30}px; overflow-y: auto;">
        <p>{'<br>'.join(commentary)}</p>
    </div>
    """

    # Grid and commentary display
    clear_output(wait=True)
    display(HTML(grid_html + commentary_html))


def manhattan_distance(pos1, pos2):

    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])


def get_valid_moves(monkey, grid_size):

    x, y = monkey
    valid_moves = []
    for dx, dy in MOVES:
        nx, ny = x + dx, y + dy
        if 0 <= nx < grid_size and 0 <= ny < grid_size:
            valid_moves.append((nx, ny))
    return valid_moves


def monkey_simulation(grid, monkey, table, banana_positions, grid_size):

    table_acquired = False
    eaten_bananas = set()
    commentary = []


    display_grid_and_commentary(grid, monkey, banana_positions, table_acquired, eaten_bananas, commentary)
    time.sleep(2)

    while banana_positions:
        if not table_acquired:
            # Moving towards the table first
            target = table
            commentary.append("Monkey is searching for the table.")
        else:
            # Moving towards the closest banana
            target = min(banana_positions, key=lambda pos: manhattan_distance(monkey, pos))
            commentary.append("Monkey is searching for the nearest banana.")


        while monkey != target:
            next_move = min(get_valid_moves(monkey, grid_size), key=lambda pos: manhattan_distance(pos, target))
            monkey = next_move

            cell_number = monkey[0] * grid_size + monkey[1] + 1
            action = "Moving to table" if not table_acquired else "Moving to banana"
            commentary.append(f"{action}: Cell {cell_number}")

            display_grid_and_commentary(grid, monkey, banana_positions, table_acquired, eaten_bananas, commentary)
            time.sleep(2)


        cell_number = monkey[0] * grid_size + monkey[1] + 1
        if not table_acquired and monkey == table:
            table_acquired = True
            grid[table[0]][table[1]] = EMPTY  # Clear the table position
            commentary.append(f"Claimed table at Cell {cell_number}")
        elif table_acquired and monkey in banana_positions:
            banana_positions.remove(monkey)
            eaten_bananas.add(monkey)
            commentary.append(f"Ate banana at Cell {cell_number}")

        display_grid_and_commentary(grid, monkey, banana_positions, table_acquired, eaten_bananas, commentary)

    commentary.append("All bananas eaten! Task complete.")
    display_grid_and_commentary(grid, monkey, banana_positions, table_acquired, eaten_bananas, commentary)


def main():
    grid_size = int(input("Enter the grid size: "))
    banana_count = int(input(f"Enter the number of bananas (1-{grid_size * grid_size - 1}): "))
    monkey_start = int(input(f"Enter the starting position of the monkey (1-{grid_size * grid_size}): "))
    table_position = int(input(f"Enter the position of the table (1-{grid_size * grid_size}): "))

    if not (1 <= monkey_start <= grid_size * grid_size) or not (1 <= table_position <= grid_size * grid_size):
        print("Invalid positions! Please try again.")
        return
    if banana_count < 1 or banana_count >= grid_size * grid_size:
        print("Invalid number of bananas!")
        return

    # Converting monkey start and table position to grid coordinates
    monkey = ((monkey_start - 1) // grid_size, (monkey_start - 1) % grid_size)
    table = ((table_position - 1) // grid_size, (table_position - 1) % grid_size)

    grid, banana_positions = initialize_grid(grid_size, banana_count, table)
    monkey_simulation(grid, monkey, table, banana_positions, grid_size)


if __name__ == "__main__":
    main()