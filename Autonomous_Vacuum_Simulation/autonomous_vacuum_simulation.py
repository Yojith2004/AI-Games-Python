# -*- coding: utf-8 -*-
"""Autonomous_Vacuum_Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sYFRLiCHAwH9-1B-156Anb8r-KCMH9EU
"""

import random
import time
from IPython.display import display, HTML, clear_output

# Constants for cell types
EMPTY = 0
DIRT = 1

# Possible movements: up, down, left, right
MOVES = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def initialize_grid(grid_size, dirt_count):

    grid = [[EMPTY for _ in range(grid_size)] for _ in range(grid_size)]
    dirt_positions = set()

    # Place dirt randomly
    while len(dirt_positions) < dirt_count:
        x, y = random.randint(0, grid_size - 1), random.randint(0, grid_size - 1)
        dirt_positions.add((x, y))

    for x, y in dirt_positions:
        grid[x][y] = DIRT

    return grid, dirt_positions


def position_to_number(pos, grid_size):

    return pos[0] * grid_size + pos[1] + 1


def display_grid_and_commentary(grid, vacuum, dirt_positions, cleaned_positions, commentary):

    grid_html = "<table style='border-collapse: collapse;'>"
    for i in range(len(grid)):
        grid_html += "<tr>"
        for j in range(len(grid[0])):
            if (i, j) == vacuum:
                cell_color = "blue"  # Vacuum's current position
            elif (i, j) in dirt_positions:
                cell_color = "red"  # Uncleaned dirt position
            elif (i, j) in cleaned_positions:
                cell_color = "green"  # Cleaned dirt position
            else:
                cell_color = "white"  # Non-dirt positions
            grid_html += f"<td style='width: 30px; height: 30px; background-color: {cell_color}; border: 1px solid black;'></td>"
        grid_html += "</tr>"
    grid_html += "</table>"

    # Grid and commentary display
    html = f"""
    <div style="display: flex;">
        <div>{grid_html}</div>
        <div style="margin-left: 20px; font-family: Arial, sans-serif;">
            <p>{commentary}</p>
        </div>
    </div>
    """
    clear_output(wait=True)
    display(HTML(html))


def get_valid_moves(vacuum, grid_size, visited):

    x, y = vacuum
    valid_moves = []
    for dx, dy in MOVES:
        nx, ny = x + dx, y + dy
        if 0 <= nx < grid_size and 0 <= ny < grid_size and (nx, ny) not in visited:
            valid_moves.append((nx, ny))
    return valid_moves


def manhattan_distance(pos1, pos2):

    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])


def vacuum_cleaner(grid, start, end, dirt_positions, grid_size):

    vacuum = start
    cleaned_positions = set()
    visited = set()
    total_dirt = len(dirt_positions)
    commentary = f"Starting at position {position_to_number(start, grid_size)}. {total_dirt} dirt patches to clean."

    while True:
        visited.add(vacuum)
        x, y = vacuum


        if (x, y) in dirt_positions:
            grid[x][y] = EMPTY
            cleaned_positions.add((x, y))
            dirt_positions.remove((x, y))
            commentary = f"Cleaned dirt at position {position_to_number(vacuum, grid_size)}. Remaining dirt: {len(dirt_positions)}."
        elif dirt_positions:
            commentary = f"No dirt at position {position_to_number(vacuum, grid_size)}. Searching for the next closest dirt."
        else:
            commentary = f"No dirt left. Moving towards the end position at {position_to_number(end, grid_size)}."

        # Refresh
        display_grid_and_commentary(grid, vacuum, dirt_positions, cleaned_positions, commentary)
        time.sleep(2)  # Animation effect


        if not dirt_positions and vacuum == end:
            commentary = f"All dirt cleaned. Reached the end position at {position_to_number(end, grid_size)}."
            break


        if dirt_positions:
            # Move toward the closest dirt patch
            next_move = min(get_valid_moves(vacuum, grid_size, visited),
                            key=lambda pos: min(manhattan_distance(pos, dirt) for dirt in dirt_positions),
                            default=None)
        else:
            next_move = min(get_valid_moves(vacuum, grid_size, visited),
                            key=lambda pos: manhattan_distance(pos, end),
                            default=None)

        if next_move:
            vacuum = next_move
        else:
            visited.clear()


    display_grid_and_commentary(grid, vacuum, dirt_positions, cleaned_positions, commentary)


def main():
    grid_size = int(input("Enter the grid size: "))
    dirt_count = int(input(f"Enter the number of dirt patches (1-{grid_size * grid_size}): "))
    start = int(input(f"Enter the starting position (1-{grid_size * grid_size}): "))
    end = int(input(f"Enter the ending position (1-{grid_size * grid_size}): "))

    if not (1 <= start <= grid_size * grid_size) or not (1 <= end <= grid_size * grid_size):
        print("Invalid start or end position!")
        return
    if dirt_count < 1 or dirt_count > grid_size * grid_size:
        print("Invalid number of dirt patches!")
        return

    # Converting start and end positions to grid coordinates
    start = ((start - 1) // grid_size, (start - 1) % grid_size)
    end = ((end - 1) // grid_size, (end - 1) % grid_size)

    grid, dirt_positions = initialize_grid(grid_size, dirt_count)
    display_grid_and_commentary(grid, start, dirt_positions, set(), "Initial grid setup.")
    vacuum_cleaner(grid, start, end, dirt_positions, grid_size)


if __name__ == "__main__":
    main()